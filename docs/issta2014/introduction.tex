\section{Introduction}

JavaScript is increasingly a popular programming language for software implementation.%; and the World Wide Web is increasingly an attractive platform for delivering applications.
HTML5 and its standardization enable Web apps to have an interactivity and feature-richness comparable to traditional desktop apps.  The latest round of browser wars make executing JavaScript more efficient, robust, secure and consistent across browsers.  Because of HTML5, more desktop and mobile operating systems actually now support implementing native apps using the JavaScript/HTML/CSS methodology ~\cite{jalangi}.
The Bring Your Own Device (BYOD) movement in Enterprise IT increases hardware heterogeneity, also making JavaScript apps \footnote{JavaScript apps are preferred in Web browsers because they are lighter weight than Java applets and they don't require installation of any proprietary plugin e.g. Flash or Silverlight} a convenient platform for delivering the front end. %(e.g. ~\cite{BNSFoffice365}).
Node.js's emergence makes JavaScript capable of implementing highly scalable servers ~\cite{nodeUpRunning}.  
Indeed, many institutions such as the Khan Academy ~\cite{khanAcademy} use JavaScript and the Web for teaching programming.

Unfortunately, despite the language's ubiquity, testing JavaScript can be challenging and cumbersome.
For example, in a typical Web app, a lot of JavaScript code is intermixed with back end logic and front end HTML ~\cite{QUnitIntro}.
Because of these dependencies, test cases cannot be fully run unless these dependencies are properly resolved.  

In this paper, we elaborate the HTML problem and present our approach to it.
HTML describes the graphical user interface (GUI) of a Web app.  In JavaScript, HTML is accessed and mutated by the Document Object Model (DOM) API.
When JavaScript code runs, the execution would encounter operations on the DOM that subtly imply the DOM tree to have a particular structure. 
In other words, when trying to run a test case, if the DOM structure does not satisfy what the code requires, eventually a DOM operation would fail and the test case would terminate prematurely.

In a simplified example of a real world game Tetris ~\cite{domtris}, suppose the function {\tt checkRows} in Sample Code ~\ref{dom0} is being unit tested concolic-ly.  
\begin{figure}
\begin{lstlisting}[caption=Example use of closures.,label=dom0]
function checkRows() {
  var field = document.getElementById("tetris");
  for (var i=field.children.length; i--;) {
    var row = $(">div#row"+i);
    if (row.children.length === 10) {
	  // ... row filled, update score
	}
  }
}
\end{lstlisting}
\end{figure}

To make the {\tt if} statement go to the {\tt True} branch, the web page's DOM structure must satisfy the following constraints:
\begin {compactitem}
\item there is an element with id {\tt tetris}
\item {\tt tetris} contain children elements, because we must first enter the {\tt for} loop
\item number of rows must be greater than or equal to the number of children that {\tt tetris} has
\item rows must have ids in the nomenclature {\tt row0}, {\tt row1}...
\item at least one of the rows must have exactly 10 children
\end {compactitem}

% cannot generate HTML for game, 
Note that the code does not imply the following, which we take for granted in a Tetris game.
\begin {compactitem}
\item Each {\tt row} is a child element of {\tt tetris}.
\item Each {\tt row} is vertically stacked: {\tt row10} is right above {\tt row9}, which is also right on top of {\tt row8}, and so on.
\item Children of a {\tt row} are blocks that make up a piece.  
\item etc.
\end {compactitem}

manual generation
random generation
greedy or just in time generation ~\cite{ZenCoding}

%contributions


Random testing, concolic testing... many prior work focus on generating inputs. 
However, the problem is that just having the inputs to a function is not sufficient.  
For example, DOMtris is a very simple Web implementation of Tetris, almost all functions don't have any input arguments.  
Yet, all these functions both depend on and mutate the state of the app.  
In the case of DOMtris, an example use case is to increase score and clean up the game pieces when the gamer has fully filled one or more rows.  
The DOM makes up a big part of a Web's app state.  
Thus in this paper we focus on the DOM.  
Indeed, DOM operations make up a majority of an app's execution and defects, according to a study by Frolin.  

A naive approach is to do just in time generation of the DOM.  
For example, if the statement is document.getElementById(), we can just return or create an element with "id".  
Yet there are 2 subtle issues.

First, there are multiple possible outputs.  

Second, dependencies in Wikipedia.  

Using a solver is easier and protects us from more complicated cases.

Our approach also supports concolic testing of DOM operations.



The new perspective is distinct from our previous motivation, which was using our tool to define test cases and drive run time execution of the program.  

Inputs can be defined for a test case in different ways: manually by test engineers writing test cases or automatically through concolic or random testing


