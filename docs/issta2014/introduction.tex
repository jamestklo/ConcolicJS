\section{Introduction}
JavaScript is increasingly a popular language for software implementation: %; and the World Wide Web is increasingly an attractive platform for delivering applications.
For end users, HTML5 and its standardization enable Web apps to have an interactivity and feature-richness comparable to those implemented for traditional desktops.  
The latest round of browser wars makes executing JavaScript more efficient, robust, secure and consistent.  
For programmers, JavaScript does not have the burden of memory management and static typing; and more desktop and mobile operating systems actually now support implementing native apps using the combination of JavaScript, HTML and CSS~\cite{jalangi}.
The Bring Your Own Device (BYOD) movement in Enterprise IT increases hardware heterogeneity, which also makes JavaScript apps\footnote{JavaScript apps are preferred in Web browsers because they are lighter weight than Java applets and they don't require installation of any proprietary plugins such as Flash and Silverlight} a conveniently portable solution for delivering the application front end (e.g.~\cite{BNSFoffice365}).
Emergence and scalability of Node.js also make JavaScript widely adopted on the server side.
Consequently, many institutions such as the Khan Academy~\cite{khanAcademy} use JavaScript for teaching programming; and JavaScript has consistently been a top 2 in the RedMonk~\cite{redmonk} popularity rankings.%~\footnote{results are based on projects hosted at GitHub and questions asked at StackOverflow}.

Yet, despite the language's ubiquity, testing JavaScript is not easy.
For example, because HTML describes the graphical user interface of a Web app, a lot of JavaScript code is written to access and mutate HTML through the Document Object Model (DOM) API.  
When JavaScript code runs, its runtime execution would encounter DOM operations that would subtly imply the DOM (and thus the webpage's HTML) having a particular tree structure.
In other words, when trying to run a test case, if the DOM structure does not satisfy what the code expects it to be, execution would fail and the test case would terminate prematurely.  Indeed, the majority of JavaScript bugs are DOM related~\cite{frolin2013}.
% Example DOM operations {\tt node.parentElement}, {\tt node.firstChild}, {\tt node.children}, and {\tt node.nextSibling}.

\subsection{Motivating Example}
To further illustrate the necessity of having a satisfiable DOM structure, suppose the {\tt function checkRows()} in Sample Code~\ref{dom0} is being unit tested concolic-ly.  
The function is simplified from a feature Chrome Experiment~\cite{domtris} that uses the DOM to implement the game Tetris.  
Concolic testing~\cite{cute} executes the app in a way to maximize path coverage; to do so, we must visit both the {\tt True} and {\tt False} branches of each {\tt if} statement in Sample Code~\ref{dom0}.  
\begin{figure}
\begin{lstlisting}[caption=Example code whose tests and execution depend on the Document Object Model having a precise tree structure. {\tt getElementById()} is equivalent to {\tt document.getElementById()}.,label=dom0]
function checkRows() {
  var field = getElementById("tetris"); 
  var i, row;
  for (i=field.children.length; i--;) {
    row = getElementById("row"+i);
    if (row.children.length === 10) {
      // ... row filled, update score
    }
  }
}
\end{lstlisting}
\end{figure}

To guide the {\tt if} statement going to the {\tt True} branch, the web page's HTML must lead to a DOM structure that satisfies many constraints:
\begin {compactitem}
\item There is an element with id {\tt tetris}.
\item {\tt tetris} contains children elements, so that we can first enter the {\tt for} loop.
\item There are rows having id's in the nomenclature {\tt row0}, {\tt row1}, etc.
\item The number of rows must be greater than or equal to the number of children that {\tt tetris} has.
\item At least one of the rows must have exactly 10 children.
\end {compactitem}

Until all of the above constraints are satisfied, the function's execution would likely lean towards an unintended path or would even halt.   
For example, when {\tt field} is {\tt null}, the property access {\tt field.children} would result in a {\tt Type Error} and consequently the rest of the function cannot be run or tested.  
Therefore, a satisfying HTML must be generated so that execution of the function and test case would not crash and can be guided towards the intended path.  

While manual generation of HTML is possible, the manual approach would quickly become tedious and not scalable.  
The reason is that a unique DOM structure is required for going through a different execution path.
For example, to go to the {\tt False} branch of the above {\tt if}, rows cannot have 10 children.
Therefore, to cover both the {\tt True} and {\tt False} branches of an {\tt if}, we must generate 2 unique DOM structures.  Generally in an {\tt if } block, the exact number of unique DOM structures per condition is 2 plus the number of {\tt else if}'s.  Loops are more difficult for achieving path coverage, because it's not easy to determine the max upper limit of loop iterations.  For example, in Sample Code ~\ref{dom0}, {\tt field} can have any number of children.

Nevertheless, the number of unique DOM structures would at least double whenever we try to cover an additional DOM-dependent condition, be it an {\tt if} or a {\tt loop}.  
Moreover, manual generation can become complex as DOM-dependent conditions can get scattered across multiple files in the code, making it labor intensive to accurately trace all of the DOM elements and relevant constraints.  
Random generation is simply not desirable because the required DOM tree may have a structure too precise for a random tree to match by chance.  
Thus the desired approach has to be automated, systematic and precise.

\subsection{Contributions}
The following are main contributions of our paper:
\begin {compactitem}
\item We propose our automated, generic, transparent and browser-independent approach for systematically generating HTML to test DOM-dependent JavaScript code.
\item We describe how JavaScript code and its execution can dynamically be analyzed for deducing constraints relevant for generating HTML.
\item We illustrate how extracted constraints can be solved into a satisfying DOM tree.
\item We present the implementation of our approach in a tool called \tool; an online video provides a demonstration.
\item We report how \tool and its generated DOM trees can help test suites improve coverage, reach complete execution, and have all their assertions done.
\end {compactitem}

\tool augments approaches that aim to generate tests automatically.  
Random testing~\cite{}, feedback directed testing~\cite{}, mutation testing~\cite{}, concolic testing~\cite{}... to our best knowledge, almost all of existing research focused on generating input parameters for testing functions or HTML inputs\footnote{by HTML inputs we include inputs for HTML text fields, forms and buttons.} for testing apps.
However, having just function parameters and HTML inputs is often insufficient.  For example, in a Web app, a properly satisfied dependency such as the DOM is often necessary for test cases and assertions to reach complete execution.\footnote{Another category of dependencies is closure variables.}
Moreover, it should be noted that the {\tt function checkRows()} does not take any input arguments, and many functions are like that in JavaScript.
Yet, these functions depend on, and would sometimes mutate, their dependencies such as the DOM.

\tool has integration with QUnit~\cite{qunit} so that existing test suites can automatically take advantage of \tool without additional manual effort.  \tool is also extensible to be integrated with other test frameworks~\cite{jstests}.
Thus given a test case, be its inputs were generated manually or automatically, \tool can be used to help the test case and its assertions get fully utilized.

% cannot generate HTML for game, 
%Note that the code does not imply the following, which we take for granted in a Tetris game.
%\begin {compactitem}竹、
%\item Each {\tt row} is a child element of {\tt tetris}.
%\item Each {\tt row} is vertically stacked: {\tt row10} is right above {\tt row9}, which is also right on top of {\tt row8}, and so on.
%\item Children of a {\tt row} are blocks that make up a piece.  
%\item etc.
%\end {compactitem}
