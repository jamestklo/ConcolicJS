\section{Introduction}

JavaScript is increasingly a popular language for software implementation: %; and the World Wide Web is increasingly an attractive platform for delivering applications.
HTML5 and its standardization enable Web apps to have an interactivity and feature-richness comparable to those implemented for traditional desktops.  The latest round of browser wars makes executing JavaScript more efficient, robust, secure and consistent across platforms.  Because of HTML5, more desktop and mobile operating systems actually now support implementing native apps using the combination of JavaScript, HTML and CSS~\cite{jalangi}.
The Bring Your Own Device (BYOD) movement in Enterprise IT increases hardware heterogeneity, which also makes JavaScript apps\footnote{JavaScript apps are preferred in Web browsers because they are lighter weight than Java applets and they don't require installation of any proprietary plugins such as Flash and Silverlight} a convenient solution for delivering the application front end (e.g.~\cite{BNSFoffice365}).
Emergence of Node.js and its scalability also make JavaScript widely adopted on the server side.
Consequently, many institutions such as the Khan Academy~\cite{khanAcademy} use JavaScript for teaching programming; and JavaScript has consistently been a top 2 in the RedMonk~\cite{redmonk} popularity rankings.%~\footnote{results are based on projects hosted at GitHub and questions asked at StackOverflow}.

Yet, despite the language's ubiquity, testing JavaScript can be challenging and cumbersome.
For example, in a typical Web app, a lot of JavaScript code is intermixed with back end logic and front end HTML~\cite{QUnitIntro}.
Such intermixes introduce dependencies when trying to run JavaScript code, and test cases cannot be fully run until those dependencies are properly resolved.

In this paper, we elaborate on the HTML problem and present our approach to it.
In a Web app, HTML describes the graphical user interface, and JavaScript code that operate an API called the Document Object Model (DOM) are abundant, because the DOM API is the standard for accessing and mutating HTML.
When JavaScript code runs, its runtime execution would encounter DOM operations that would subtly imply the DOM having a particular tree structure. 
In other words, when trying to run a test case, if the DOM structure does not satisfy what the code expects it to be, execution would fail and the test case would terminate prematurely.
A recent study in the literature~\cite{frolin2013} discovered that the majority of bugs in JavaScript are related to operations on the DOM.

To further illustrate the necessity of a satisfiable DOM structure, suppose the function {\tt checkRows} in Sample Code ~\ref{dom0} is being unit tested concolic-ly.  
The function is simplified from a feature Chrome Experiment~\cite{domtris} that uses the DOM to implement Tetris.  
Concolic testing~\cite{cute} executes the app in a way to maximize path coverage; to do so, we must visit both the {\tt True} and {\tt False} branches of each {\tt if} statement in Sample Code ~\ref{dom0}.
\begin{figure}
\begin{lstlisting}[caption=Example that needs tracing and solver. The function getElementById() is equivalent to document.getElementById(),label=dom0]
function checkRows() {
  var field = getElementById("tetris"); 
  var i, row;
  for (i=field.children.length; i--;) {
    row = getElementById("row"+i);
    if (row.children.length === 10) {
      // ... row filled, update score
    }
  }
}
\end{lstlisting}
\end{figure}

To make the {\tt if} statement go to the {\tt True} branch, the web page's DOM structure must satisfy the following constraints:
\begin {compactitem}
\item there is an element with id {\tt tetris}
\item {\tt tetris} contains children elements, because we must first enter the {\tt for} loop
\item there are rows having id's the nomenclature {\tt row0}, {\tt row1}...
\item the number of rows must be greater than or equal to the number of children that {\tt tetris} has
\item at least one of the rows must have exactly 10 children
\end {compactitem}

While manual generation of HTML is possible, the manual approach would quickly become tedious and not scalable.  
The reason is that an unique DOM structure is required for going through different execution paths.  
For example, to go to the {\tt False} branch of the above {\tt if} statement, rows cannot have 10 children.
Therefore, when an {\tt if} statement depends on DOM operations to decide which branch to go, any addition of such {\\tt if} statements to the code would double the number of unique DOM structures for achieving path coverage, leading to exponential growth.
Moreover, because not every {\tt if} statement depends on DOM operations, manual generation can become complex and labour intensive to keep track of all relevant {\tt if} statements and multiple DOM elements involved.



% the problem can be hard
% manual generation
% random generation
% greedy or just in time generation ~\cite{ZenCoding}
% constraint-based generation
% constraint solver
% justify for tracing, look ahead, and generating constraints
% justify for using a solver, rather than heuristics to resolve constraints

% cannot generate HTML for game, 
Note that the code does not imply the following, which we take for granted in a Tetris game.
\begin {compactitem}
\item Each {\tt row} is a child element of {\tt tetris}.
\item Each {\tt row} is vertically stacked: {\tt row10} is right above {\tt row9}, which is also right on top of {\tt row8}, and so on.
\item Children of a {\tt row} are blocks that make up a piece.  
\item etc.
\end {compactitem}

manual generation
random generation


%contributions

0) DOM-specific tracing
1) DOM solver
2) Generating HTML
3) Integration with QUnit



DOM mutations
Attributes


Random testing, concolic testing... many prior work focus on generating inputs. 
However, the problem is that just having the inputs to a function is not sufficient.  
For example, DOMtris is a very simple Web implementation of Tetris, almost all functions don't have any input arguments.  
Yet, all these functions both depend on and mutate the state of the app.  
In the case of DOMtris, an example use case is to increase score and clean up the game pieces when the gamer has fully filled one or more rows.  
The DOM makes up a big part of a Web's app state.  
Thus in this paper we focus on the DOM.  
Indeed, DOM operations make up a majority of an app's execution and defects, according to a study by Frolin.  

A naive approach is to do just in time generation of the DOM.  
For example, if the statement is document.getElementById(), we can just return or create an element with "id".  
Yet there are 2 subtle issues.

First, there are multiple possible outputs.  

Second, dependencies in Wikipedia.  

Using a solver is easier and protects us from more complicated cases.

Our approach also supports concolic testing of DOM operations.



The new perspective is distinct from our previous motivation, which was using our tool to define test cases and drive run time execution of the program.  

Inputs can be defined for a test case in different ways: manually by test engineers writing test cases or automatically through concolic or random testing


