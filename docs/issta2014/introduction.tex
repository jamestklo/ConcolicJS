\section{Introduction}
JavaScript is increasingly a popular language for software implementation: %; and the World Wide Web is increasingly an attractive platform for delivering applications.
HTML5 and its standardization enable Web apps to have an interactivity and feature-richness comparable to those implemented for traditional desktops.  
The latest round of browser wars makes executing JavaScript more efficient, robust, secure and consistent.  
Because of HTML5, more desktop and mobile operating systems actually now support implementing native apps using the combination of JavaScript, HTML and CSS~\cite{jalangi}.
The Bring Your Own Device (BYOD) movement in Enterprise IT increases hardware heterogeneity, which also makes JavaScript apps\footnote{JavaScript apps are preferred in Web browsers because they are lighter weight than Java applets and they don't require installation of any proprietary plugins such as Flash and Silverlight} a convenient solution for delivering the application front end (e.g.~\cite{BNSFoffice365}).
Emergence of Node.js and its scalability also make JavaScript widely adopted on the server side.
Consequently, many institutions such as the Khan Academy~\cite{khanAcademy} use JavaScript for teaching programming; and JavaScript has consistently been a top 2 in the RedMonk~\cite{redmonk} popularity rankings.%~\footnote{results are based on projects hosted at GitHub and questions asked at StackOverflow}.

Yet, despite the language's ubiquity, testing JavaScript can be challenging and cumbersome.
For example, in a typical Web app, a lot of JavaScript code is intermixed with back end logic and front end HTML~\cite{QUnitIntro}.
Such intermixes introduce dependencies when trying to run JavaScript code, consequently test cases cannot be fully run until those dependencies are properly resolved.

In this paper, we elaborate on the HTML problem and our approach to it.
In a Web app, HTML describes the graphical user interface.  The standard API for accessing and mutating HTML is the Document Object Model (DOM) API; thus JavaScript code that operate on the DOM are abundant in Web apps.
When JavaScript code runs, its runtime execution would encounter DOM operations that would subtly imply the DOM having a particular tree structure. 
In other words, when trying to run a test case, if the DOM structure does not satisfy what the code expects it to be, execution would fail and the test case would terminate prematurely.
Indeed, a majority of JavaScript bugs are related to the DOM~\cite{frolin2013}.

\subsection{Motivating Example}
To further illustrate the necessity of a satisfiable DOM structure, suppose the {\tt function checkRows()} in Sample Code ~\ref{dom0} is being unit tested concolic-ly.  
The function is simplified from a feature Chrome Experiment~\cite{domtris} that uses the DOM to implement Tetris.  
Concolic testing~\cite{cute} executes the app in a way to maximize path coverage; to do so, we must visit both the {\tt True} and {\tt False} branches of each {\tt if} statement in Sample Code ~\ref{dom0}.
\begin{figure}
\begin{lstlisting}[caption=Example code whose tests and execution depend on the Document Object Model having a precise structure. {\tt getElementById()} is equivalent to {\tt document.getElementById()}.,label=dom0]
function checkRows() {
  var field = getElementById("tetris"); 
  var i, row;
  for (i=field.children.length; i--;) {
    row = getElementById("row"+i);
    if (row.children.length === 10) {
      // ... row filled, update score
    }
  }
}
\end{lstlisting}
\end{figure}

To guide the {\tt if} statement going to the {\tt True} branch, the web page's DOM structure must satisfy the many constraints:
\begin {compactitem}
\item there is an element with id {\tt tetris}
\item {\tt tetris} contains children elements, because we must first enter the {\tt for} loop
\item there are rows having id's in the nomenclature {\tt row0}, {\tt row1}, etc.
\item the number of rows must be greater than or equal to the number of children that {\tt tetris} has
\item at least one of the rows must have exactly 10 children
\end {compactitem}

%If any of the above constraints is not satisfied, the execution would lean towards a wrong path or even crash, e.g. when {\tt field} or {\tt row} is null.

While manual generation of HTML is possible, the manual approach would quickly become tedious and not scalable.  
The reason is that an unique DOM structure is required for going through a different execution path.
For example, to go to the {\tt False} branch of the above {\tt if} condition, rows cannot have 10 children.
Therefore, to cover both the {\tt True} and {\tt False} branches of an {\tt if} condition, 2 unique DOM structures are necessary.
Generally, the exact number of unique DOM structures is 2 plus the number of {\tt else if}'s in the condition.
Loops are more difficult for achieving path coverage, because it's not easy to determine the max upper limit of loop iterations.  For example, in Sample Code ~\ref{dom0}, {\tt field} can have any number of children.

Consequently, whenever there is an {\tt if} or {\tt loop} condition depending on the DOM, any addition of such conditions would at least double the number of unique DOM structures necessary for path coverage, leading to exponential growth.
Moreover, manual generation can become complex as DOM-depending conditions can get scattered across multiple files in the code base, making it labor intensive to accurately trace all of the constraints and DOM elements.
Random generation is simply not desirable because the required DOM tree may contain many DOM elements that have to be sophisticatedly organized in a precise structure.

\subsection{Contributions}
In this paper we propose our automated approach for executing and testing JavaScript code that depend on the DOM:
\begin {compactitem}
\item DOM tracing and constraints
\item DOM solver
\item Integration with unit testing frameworks such as QUnit
\item We present the implementation of our approach is a tool called \tool; an online video provides a demonstration.
\item We report the effecficay 
\end {compactitem}

% making test cases runnable


% cannot generate HTML for game, 
Note that the code does not imply the following, which we take for granted in a Tetris game.
\begin {compactitem}
\item Each {\tt row} is a child element of {\tt tetris}.
\item Each {\tt row} is vertically stacked: {\tt row10} is right above {\tt row9}, which is also right on top of {\tt row8}, and so on.
\item Children of a {\tt row} are blocks that make up a piece.  
\item etc.
\end {compactitem}


% Random testing, concolic testing... many prior work focus on generating inputs. 
% However, the problem is that just having the inputs to a function is not sufficient.  
% For example, DOMtris is a very simple Web implementation of Tetris, almost all functions don't have any input arguments.  
% Yet, all these functions both depend on and mutate the state of the app.  
% In the case of DOMtris, an example use case is to increase score and clean up the game pieces when the gamer has fully filled one or more rows.  
% The DOM makes up a big part of a Web's app state.  
% Thus in this paper we focus on the DOM.  
% Indeed, DOM operations make up a majority of an app's execution and defects, according to a study by Frolin.  

% A naive approach is to do just in time generation of the DOM.  
% For example, if the statement is document.getElementById(), we can just return or create an element with "id".  
% Yet there are 2 subtle issues.

% First, there are multiple possible outputs.  

% Second, dependencies in Wikipedia.  

% Using a solver is easier and protects us from more complicated cases.

% Our approach also supports concolic testing of DOM operations.



% The new perspective is distinct from our previous motivation, which was using our tool to define test cases and drive run time execution of the program.  

% Inputs can be defined for a test case in different ways: manually by test engineers writing test cases or automatically through concolic or random testing


