\section{Approach}
%Each DOM operation in any part of the code is like a piece of a puzzle describing a subset clue of the overall DOM tree.  \tool has to systematically extract these puzzle pieces and analyse them collectively for generating a satisfiable DOM.  


\header{Decorated Execution.}
Decorated execution 
To generate a dynamic backward slice, we must accurately capture a condition's potential nested composition and potential dynamic precedence; and decorated execution is a simple and efficient way of doing the capture.  
% what decorated execution is, how it works, why it works
Sample code\ref{decorated} illustrates the semantics of decorated execution. 
% example for: 1) precedence, 2)
% functions, boundary to native functions
% we call it decorated execution because we wrap around each value.  

Decorated execution naturally captures the nested composition of conditions, i.e. when conditions are composed of sub-conditions linked by logical operators (e.g. {\tt or}'s, {\tt and}'s, {\tt not}'s) nested inside one another.



Each condition is composed of 1 or more sub-conditions nested inside or linked beside other sub-conditions.  Each sub-condition is composed of 1 or more variables being compared to other variables.  

\begin{figure}
\begin{lstlisting}[caption=Example showing how code is decorated for logging execution and using the trace to construct a dynamic backward slice,label=decorated]  
function DecoratedExecution() {
  // 2 lines of original code
  var a = row.children.length === b; 
  if (a) {}
  // ...
  // decorated version of original code
  var a = _SHEQ(_GET(_GET(row, "children"), "length"), b);
  if () {}
  // ...
}
\end{lstlisting}
\end{figure}
\begin{figure}
\begin{lstlisting}[caption=Example showing how code is decorated for logging execution and using the trace to construct a dynamic backward slice,label=sheq]  
function DecoratedExecution() {
  // 2 lines of original code
  var a = row.children.length === b; 
  if (a) {}
  // ...
  // decorated version of original code
  var a = _SHEQ(_GET(_GET(row, "children"), "length"), b);
  if (__condStart()) {}
  // ...
}
\end{lstlisting}
\end{figure}
%eval


% why not shadow execution, as in jalangi 
% describe what decorated execution is


%(a && a.b)
%_AND(a, _GET(a,b)); 
%_AND((_t=a, _t), _t && _GET(_t, b));

%result = f0(input) || f1(input);
%_OR(

\header{Dynamic Backward Slicer.}
In a condition, dynamic backward slicing discovers what DOM operations a condition has.  
During execution, given a variable at a point in time, a dynamic backward slice traces how the variable has arrived at its current value: what operations or calculations had been previously done.  
For example, if the variable {\tt a} equals to {\tt row.children.length === b} at line 6 during execution, {\tt a}'s backward slice would be backward slices of {\tt row.children.length} and {\tt b}, linked by the strict equal {\tt ===} operator.  
Eventually a dynamic backward slice would lead us to original inputs, constant values, and environmental dependencies such as the DOM.  
For example, a dynamic backward slice of {\tt row} would lead us to the DOM element with ID {\tt "row"+i}, where {\tt "row"} is a constant string, and {\tt i} has a backward slice leading to {\tt field.children.length}, which would lead us to the DOM element with ID {\tt "field"}.


\header {Dynamic Tracer.}

\header{DOM Solver.}
% SMT-lib language, swappable between CVC and Z3.
	% take advantage of Moore's law in terms of hardware performance and breakthroughs in constraint solvers
	% future compatibility for multiple data types

\header{Conditional Slicing.}

\header{Integration with QUnit and Selenium.}


\header{Limited Path Coverage.}


