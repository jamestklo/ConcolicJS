\section{Approach}
Given a piece of JavaScript code and a test case, our goal is to generate HTML so that the HTML's DOM structure would guide and support the execution of the code being tested towards the intended path.  
As an overview, our approach is to first instrument the JavaScript code so that we can log the code's execution for producing a dynamic backward slice and a dynamic trace.  
Next we analyze the trace and the slice to extract DOM-specific operations and to deduce constraints, which the DOM solver would take as input for generating a suitable DOM structure and corresponding HTML.  
Then we integrate the HTML into a test framework for running assertions.  


\begin{figure}
\begin{lstlisting}[caption=Example showing how code is instrumented for dynamic analysis.,label=sheq]  
function beforeInstrumentation(i) {
  var row = getElementById("row"+i);
  var a = row.children.length === b; 
  if (a) {}
}

function afterInstrumentation(i) {
  var row = _CALL(getElementById, _ADD(_CONST("STRING filename.js 0", "row"), i));
  var a = _SHEQ(_GET(_GET(row, "children"), "length"), b);
  if (__cond("IF_NAME filename.js 1", a)) {}
}
\end{lstlisting}
\end{figure}

\header{Decorated Execution.}
Decorated execution is where we statically instrument the JavaScript code so that the execution of each JavaScript operator can be captured and decorated with taint data for producing a dynamic trace and a dynamic backward slice.  Sample code \ref{sheq} illustrates the semantics of decorated execution.  
A general rule of thumb is that we transform each JavaScript operator into a function call.  For example, the {\tt .} operator is transformed into a call to {\tt \_GET()}; thus {\tt row.children} becomes {\tt \_GET(row, "children")}.  {\tt \_SHEQ} represents the strict equal operator "{\tt ===}".  

A special case happens when we transform the {\tt \&\&} and {\tt |}{\tt |} operators, in which we have to consider the precedence of the operator's left hand side.   
For example, if the code is {\tt a \&\& a.b}, the transformed version becomes {\tt \_AND(a, a.b)}; yet we don't want to execute {\tt a.b} when {\tt a} is {\tt null} or {\tt undefined}.  
The left hand side can be a call to a function that may change the internal state of the application (e.g. {\tt appendLog() \&\& update()})
Thus our solution is to assign the left hand side into a temporary variable, and then check the value of the temporary variable before executing the right hand side: {\tt \_AND(t = a, t \&\& \_GET(a, "b"))} and {\tt \_AND(t = \_CALL(appendLog), t \&\& \_CALL(update))}.  

Another special case is the {\tt ++} and {\tt --} operators.  For operations like {\tt i++}, we have to assign {\tt i} to a temporary variables first as return value before incrementing {\tt i}.
Decorated execution is named after the decorator pattern~\cite{decoratorPattern}; the return value of each operator function (e.g. {\tt \_AND()}) is decorated with taint data for dynamic analysis, e.g. dynamic slicing and dynamic symbolic execution.  
% functions, boundary to native functions


\header{Backward Slicer}
% would a diagram be good?
During execution, the calls to the operator functions are nested inside one another.  For example, in Sample Code \ref{sheq}, there's a call to {\tt \_GET()} nested inside the call to {\tt \_SHEQ()}.  
Therefore, if we simply put the name of the operator function inside the taint data, we can easily generate a backward slice via a tree traversal.  

In Sample Code \ref{sheq}, the variable {\tt a} equals to {\tt row.children.length === b}.  Thus {\tt a}'s backward slice must contain the the backward slices of {\tt b} and {\tt row.children.length}, linked by the strict equal {\tt ===} operator.  
At line 8, the decorated object returned by {\tt \_SHEQ()}, assigned to the variable {\tt a}, is the tree parent of 2 decorated objects: {\tt b}, and the decorated object returned by the {\tt \_GET()} call.  
Because the tree children of a decorated object always come from earlier executions (e.g. get children is executed before get length, before strict equal), the tree's hierarchical structure also preserves the temporal order in which operator functions are executed.  
The backward slicer traverses the tree of decorated objects, yields a temporal history of the code's runtime execution, and generates a dynamic backward slice.  

During the traversal, we identify conditions that contain DOM operations and extract these DOM operations accordingly.  Each tree leaf represents an input or a constant.  
For example, a dynamic backward slice of {\tt row} would lead us to the DOM element with ID {\tt "row"+i}, where {\tt "row"} is a constant string, and {\tt i} has a backward slice leading to {\tt field.children.length}, which would lead us to the DOM element with ID {\tt "field"}.  
Because variables can be used multiple times, each variable can belong to more than 1 tree and can have more than 1 parent, even though a variable would never be a tree ancestor of any of its own parents.  


\header {Trace Mapper, Constraints Deducer} 
For each condition, the backward slicer would yield what DOM operations the condition has and how these DOM operations are related or interdependent on one another; the MapDeducer would aggregate multiple conditions and deduce constraints for the DOM solver to generate a satisfiable HTML.  
The MapDeducer works like MapReduce.  So far everything is code-oriented in which we focus on each condition and its dynamic backward slice.  The MapDeducer would transition the focus to be DOM-oriented in which we assemble clues about the same part of the DOM tree that are scattered across multiple lines of code.  
The MapDeducer would then put together the processed clues across multiple parts of the DOM tree back together, into a single set of constraints for the DOM solver to generate a satisfiable HTML.  

Recall the jQuery example from the Challenges section.  The MapDeducer would 
\header{DOM Solver.}
The DOM solver takes the constraints defined by the Deducer and attempts to generate a satisfiable HTML.  The solver is implemented as an extension of a SMT solver and would report anything not satisfiable.  
% how to create rules in DOM solver, example rules.  Intuition behind it.
% why not XML solver, not scalable
% SMT-lib language, swappable between CVC and Z3.
	% take advantage of Moore's law in terms of hardware performance and breakthroughs in constraint solvers
	% future compatibility for multiple data types

	
\header{Conditional Slicing.}


\header{Integration with QUnit and Selenium.}


\header{Limited Path Coverage.}

