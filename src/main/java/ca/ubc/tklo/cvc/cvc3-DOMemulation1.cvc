OPTION "incremental";
OPTION "produce-models";
OPTION "interactive-mode";

Node: TYPE;
root: 				(Node) -> BOOLEAN;			% n1 is root

parent: 			(Node, Node) -> BOOLEAN;	% n1 is parent of n2
child: 				(Node, Node) -> BOOLEAN;	% n1 is child of n2
children:			(Node, Node, INT) -> BOOLEAN;
childIndex: 		(Node) 		 -> INT;
childrenLength:		(Node)	 	 -> INT;

following_sibling: 	(Node, Node) -> BOOLEAN;
preceding_sibling: 	(Node, Node) -> BOOLEAN;

descendant: 		(Node, Node) -> BOOLEAN;
ancestor: 			(Node, Node) -> BOOLEAN;

firstChild: 		(Node, Node) -> BOOLEAN;	
lastChild: 			(Node, Node) -> BOOLEAN;

nextSibling:		(Node, Node) -> BOOLEAN;
previousSibling:	(Node, Node) -> BOOLEAN;

equal: 				(Node, Node) -> BOOLEAN;


%getElementById, getElementByTagName, CSS selector, attributes, properties
% forall node x, tag t, tag s : hasTag(x, t) -> not hasTag(x, s) 
% descendant relationship
ASSERT FORALL (x, y: Node):		% everything is descendant of root
	(root(y) AND DISTINCT(x,y)) => descendant(x,y);	

ASSERT FORALL (x: Node):		% a child cannot be child of itself
	NOT(child(x,x));

ASSERT FORALL (x, y: Node):		% a child node cannot be parent of its parent node
	child(x,y) => NOT(child(y,x));

ASSERT FORALL (x, y, z: Node):	% each node can have only 1 parent
	(child(x,y) AND DISTINCT(y,z)) => NOT(child(x,z));
		
ASSERT FORALL (x, y: Node):		% descendant must follow a child relationship (NOT parent)
	descendant(x, y) <=> child(x, y) OR ( EXISTS (z: Node): descendant(x, z) AND child(z, y) );

ASSERT FORALL (x,y:Node, j:INT):
	children(x, y, j) => child(x, y) AND j >= 0;
	
ASSERT FORALL (x:Node, j:INT):
	(childIndex(x) = j)	<=> EXISTS (y: Node): ( children(x, y, j) );

ASSERT FORALL (y:Node, j:INT):
	childrenLength(y) = j <=> EXISTS(x:Node): lastChild(x, y) AND children(x, y, j);
		
ASSERT FORALL (x, y:Node):
	firstChild(x, y) <=> children(x, y, 0);

ASSERT FORALL (x, z:Node): 	
	lastChild(x, z) => EXISTS(j:INT): ( j >= 0 AND children(x, z, j) AND (NOT(EXISTS (y: Node, k:INT): children(y, z, k) AND k > j)) );

% following-sibling 
ASSERT FORALL (x: Node):		% a sibling cannot be sibling of itself
	NOT(following_sibling(x, x));
	
ASSERT FORALL (x, z: Node): % siblings share the same parent
	following_sibling(x, z) <=> EXISTS (y: Node, i, j:INT): (children(x, y, i) AND children(z, y, j) AND i > j);

% DOM API
ASSERT FORALL (x: Node):		% a sibling cannot be sibling of itself
	NOT(nextSibling(x, x));
	
ASSERT FORALL (x, z: Node): % siblings share the same parent
	nextSibling(x, z) <=> EXISTS (y: Node, i, j:INT): (children(x, y, i) AND children(z, y, j) AND i=j+1);
	
	
% reverse
ASSERT FORALL (x, y: Node):
	parent(x, y) <=> child(y, x);

ASSERT FORALL (x, y: Node):
	parent(x, y) => NOT(parent(y, x));

ASSERT FORALL (x, y: Node):
	ancestor(x, y) <=> descendant(y, x);

ASSERT FORALL (x, y: Node):
	ancestor(x, y) => NOT(ancestor(y, x));
		
ASSERT FORALL (x, z: Node):
	preceding_sibling(x, z) <=> following_sibling(z, x);

ASSERT FORALL (x, z: Node):
	preceding_sibling(x, z) => NOT(preceding_sibling(z, x));	

ASSERT FORALL (x, z: Node):
	previousSibling(z, x) <=> nextSibling(x, z);
	
ASSERT FORALL (x, z: Node):
	previousSibling(z, x) => NOT(previousSibling(x, z));

	
% equal	
ASSERT FORALL (x, z: Node):
	equal(x, z) <=> EXISTS (y: Node): parent(x,y) AND parent(z,y);
	
ASSERT FORALL (x, z: Node):
	equal(x, z) <=> EXISTS (y: Node): firstChild(x,y) AND firstChild(z,y);

ASSERT FORALL (x, z: Node):
	equal(x, z) <=> EXISTS (y: Node): lastChild(x,y) AND lastChild(z,y);
	
ASSERT FORALL (x, z: Node):
	equal(x, z) <=> EXISTS (y: Node): parent(y, x) AND parent(y, z) AND (childIndex(x) = childIndex(z));

ASSERT FORALL (x, z: Node):
	equal(x, z) <=> EXISTS (y: Node): nextSibling(x,y) AND nextSibling(z,y);

ASSERT FORALL (x, z: Node):
	equal(x, z) <=> EXISTS (y: Node): previousSibling(x,y) AND previousSibling(z,y);
	
%%%

